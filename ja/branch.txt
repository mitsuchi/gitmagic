== ブランチの魔法使い ==

手軽にブランチを作れたりマージできたりするのは、Gitの最大の特徴だ。

*問題*: 外部的な要因で、いったん違う作業をしなきゃならなくなった。公開中のバージョンに、前触れもなくやばいバグが見つかった。ある機能の開発の締め切りが急に前倒しになった。プロジェクトの主要部分を担当する開発者が辞めそうだ。どの場合にも共通するのは、今やってることをいったん中断して、突如としてぜんぜん違うことをしなきゃならないってことだ。

思考の連なりをじゃまされると、生産性が落ちる。作業を切り替えるのがやっかいなほどそうだ。中央集権型のバージョン管理の場合、まず中央サーバから最新の作業用コピーをダウンロードしてくる必要がある。一方、分散型ならもっとうまくできる。つまり、必要なバージョンのクローンを手元につくればいい。

でも、クローンを作るってことは結局、作業ディレクトリとか、そのバージョン時点までのぜんぶの履歴をコピーすることになる。たしかにGitはファイルの共有とかハードリンクを使って無駄を省いてくれるけど、ファイルそのものは新しい作業ディレクトリに新しく再作成しなくちゃならない。

*解決*: Gitにはこういう状況に対するいい道具がある。そいつはクローンを作るよりも速いし、ディスクの無駄もない。*git branch* を使おう。

この呪文で、作業ディレクトリ内のファイルは突然別のバージョンに姿を変える。この変身は単に履歴の中を進んだり戻ったりできるってだけじゃない。最新のリリース用のバージョンから、実験用のバージョンにも移れるし、いま開発中のバージョンや友達のバージョンなんかにも移れる。

=== 「上司が来たぞ」キー ===

こんなゲームをやったことはないだろうか。特定のキー（上司キー）を押すと、突然画面がエクセルかなんかに切り替わる。なので、職場でゲームをやってるときに上司が来たら、そのキーを押して画面を隠せばいいみたいなやつだ。

好きなディレクトリでこうやってみよう。

 $ echo "ぼくは上司より利口だ" > myfile.txt
 $ git init
 $ git add .
 $ git commit -m "最初のコミット"

これでGitのレポジトリができた。その中には、あるメッセージの入った一つのファイルが管理されてる。じゃあ、次にこうしてみよう。

 $ git checkout -b boss  # こうやっても何も変わらないように見える
 $ echo "ぼくより上司のほうが賢い" > myfile.txt
 $ git commit -a -m "別のコミット"

こうすると、myfile.txtを上書きしてコミットしたように見える。でもそれは錯覚だ。こう打ってみよう。

 $ git checkout master  # 元のバージョンに切り替える

するとテキストファイルはなんと元通り！そしてもし上司がこのディレクトリを覗こうとしてるならこうすればいい。

 $ git checkout boss  # 上司に見られてもいいバージョンに切り替える

この二つのバージョンは好きなだけ切り替えられるし、コミットもそれぞれ互いに関係なくできる。

=== 汚れ仕事 ===

[[branch]]
ある部分を開発しているときに、何らかの理由で古いバージョンに戻る必要がでてきたとしよう。その中で、特定の箇所がどういうふうに動いてるかをみるために一時的にprint文を追加したい。そんな場合はこうしよう。

 $ git commit -a
 $ git checkout SHA1_HASH

これでもう、汚い一時的なコードをどこに足しても大丈夫だ。変更をコミットしてもいい。それが終わったら、

 $ git checkout master

とすれば元の作業に戻れる。古いバージョンに戻る時点でコミットされてなかった変更は引き継がれないことに注意しよう。

さっきの一時的な変更をやっぱり保存したかった場合も簡単で、

 $ git checkout -b dirty

としてから、マスターブランチに切り替える前にコミットすればいい。その後で一時的な汚いブランチの方に戻りたければ単にこう打つ。

 $ git checkout dirty

このコマンドについては、実は以前の章で触れている（古い状態に戻るっていう話題のときに）。さて、話をまとめるとこうだ。ファイルは指定した状態に変化する。でもそれにはマスターブランチを離れる必要がある。それ以降のコミットによって、ファイルはまた別の道を進むことになる。その道には後から名前をつけてもいい。

言いかえると、古い状態にチェックアウトした後は、自動的に名前のないブランチに切り替わる。それに名前をつけて保存するには *git checkout -b* とすればいい。

=== サクッと修正 ===

もし何かの作業の途中で、それを中断して新しく見つかったバグを直すように言われたらこうしよう。

$ git commit -a
$ git checkout -b fixes SHA1_HASH

そしてバグを修正したらこうする。

 $ git commit -a -m "バグを直した"
 $ git push  # 中央サーバへ
 $ git checkout master

そして元の作業を再開しよう。

=== 中断のないワークフロー ===

プロジェクトによっては、コードを事前にレビューすることがある。その場合、レビューする人たちがやりやすいように、大きな変更を２つか３つの小さな変更に分けて、それぞれを順番にレビューしてもらうってことはあるかもしれない。

でももし、１つめが承認されて取り込まれるまで２つめを書けないとしたらどうだろう？多くのバージョン管理システムでは、１つめをレビュアーに送ったら、それが承認されるまで２つめに手をつけるのを待たなきゃいけない。

まあ実際にはちょっと違うけど、でもこれらのシステムでは１つめが取り込まれる前に２つめを編集するのはめんどくさいし難しい。Gitならブランチを作るのもマージするのにも痛みがない（速くて手軽っていうこと）。なので、１つめをコミットしてレビュアーに送った後はこうしよう。

 $ git checkout -b part2

次に、１つめが承認されるのを待たずに２つめの変更作業にかかろう。１つめが承認されて取り込まれたらこうすればいい。

 $ git checkout master
 $ git merge part2
 $ git branch -d part2  # このブランチはもういらない

そして２つめの変更をレビューしてもらう。

でも、ことはそんなに簡単じゃないかもしれない。たとえば、１つめで何か間違いをしたとしよう。そしたら取り込まれる前に修正しなきゃならない。でも大丈夫。そんなときは、まず次のコマンドでマスターブランチに切り戻そう。

 $ git checkout master

１つめの変更に関わる部分を修正して、承認されるのを待つ。承認されなかったら、単にこのステップを繰り返せばいい。１つめに関するこの修正は、２つめのほうにも当然マージしたいだろうから、こうしよう。

 $ git checkout part2
 $ git merge master

これで後は最初の場合と同じだ。もしも１つめが承認されて取り込まれたら、こうすればいい。

 $ git checkout master
 $ git merge part2
 $ git branch -d part2

そして再び、２つめの変更はレビュー待ちになる。

分割がいくつになっても、このやり方は簡単に拡張できる。

=== よせ集めをきれいに作り直す ===

プロジェクトのあらゆる側面についての開発をひとつの同じブランチでやりたいってのはありそうなことだ。その際、自分にとっては開発中の状態を維持したまま、他の人にはきちんと編成されたコミットだけを見せたいとする。そんなときは、対になる２つのブランチから始めよう。

  $ git checkout -b sanitized (訳注：消毒済みブランチ)
  $ git checkout -b medley　　(訳注：よせ集めブランチ)

それから、よせ集めブランチ上で、なんでも好きなことをしよう。バグを修正したり、新しい機能を追加したり、一時的なコードを足したり。その際、途中ではまめにコミットしよう。それからこうする。

  $ git checkout sanitized
  $ git cherry-pick SHA1_HASH

こうやってよせ集めブランチでのコミットを指定すると、それが消毒済みブランチに適用される。うまいことつまみ食い(cherry-pick)してやれば、一時的なコードは含まれず、互いに関連のあるコミットだけを含むようなブランチをうまく構成することができる。

=== ブランチを管理する ===

次のコマンドでブランチを一覧表示しよう。

 $ git branch

その中には必ず「master」という名前のブランチがある。これはデフォルトで出発点となるものだ。masterブランチにはさわらず、新しいブランチを作ってそれをいじるべきだという人もいる。

*-d* や *-m* といったオプションをつけることで、ブランチを消したり名前を変更することができる。詳しくは *git help branch* してみてほしい。

masterブランチは決めごととして便利だ。だれかのレポジトリには必ずその名前のブランチがあって、そのプロジェクトの公式なバージョンが入ってると想定することができる。masterブランチは、名前を変更したり跡形もなく消したりすることもできるけど、この慣習を尊重したほうがよさそうだ。

=== 一時的なブランチ ===

Gitをしばらく使っていると、寿命の短いブランチを似たような理由で作りがちだってことに気がつくかもしれない。いまの状態を単に保存しておいて、新しく見つかった緊急のバグ修正かなにかをするためにいったん古いバージョンに戻る、みたいな場合に。

例えるなら、テレビを見てるときに、他の局で何をやってるかみるためにチャンネルをちょっとだけ変えるみたいな話だ。でも、テレビなら単にボタンをいくつか押すだけですむけど、Gitの場合はまず一時的なブランチを作って、チェックアウトして、削除して、コミットしないといけない。幸いなことに、Gitにはこのためのショートカットがあってリモコン並に便利だ。

 $ git stash

こうすると、いまの状態が一時的な場所(訳注：stash＝隠し場所）に保存されたうえで、状態は一つ前にもどる。作業ディレクトリは変更を始める前とまったく同じ状態になるので、あとはバグを修正するなり、上流の変更を取り込むなりすればいい。一時的に保存されてる方の状態に戻りたいと思ったらこうしよう。

 $ git stash apply  # いくつかマージの衝突を解決しないといけなくなるかも

stashで保存する一時領域は複数もつことができるし、いろんな方法で扱うことができる。詳しくは *git help stash* としてほしい。想像のとおり、Gitはこの魔法みたいな仕掛けを、ブランチを使って実現してる。

=== やりたいように仕事をしよう ===

Applications such as http://www.mozilla.com/[Mozilla Firefox] allow you to open multiple tabs and multiple windows. Switching tabs gives you different content in the same window. Git branching is like tabs for your working directory. Continuing this analogy, Git cloning is like opening a new window. Being able to do both improves the user experience.

On a higher level, several Linux window managers support multiple desktops.
Branching in Git is similar to switching to a different desktop, while cloning
is similar to attaching another monitor to gain another desktop.

Yet another example is the http://www.gnu.org/software/screen/[*screen*] utility. This gem lets you create, destroy and switch between multiple terminal sessions in the same terminal. Instead of opening new terminals (clone), you can use the same one if you run *screen* (branch). In fact, you can do a lot more with *screen* but that's a topic for another text.

Cloning, branching, and merging are fast and local in Git, encouraging you to use the combination that best suits you. Git lets you work exactly how you want.
