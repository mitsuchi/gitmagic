== ブランチの魔法使い ==

手軽にブランチを作れたりマージできたりするのは、Gitの最大の特徴だ。

*問題*: 外部的な要因で、いったん違う作業をしなきゃならなくなった。公開中のバージョンに、前触れもなくやばいバグが見つかった。ある機能の開発の締め切りが急に前倒しになった。プロジェクトの主要部分を担当する開発者が辞めそうだ。どの場合にも共通するのは、今やってることをいったん中断して、突如としてぜんぜん違うことをしなきゃならないってことだ。

思考の連なりをじゃまされると、生産性が落ちる。作業を切り替えるのがやっかいなほどそうだ。中央集権型のバージョン管理の場合、まず中央サーバから最新の作業用コピーをダウンロードしてくる必要がある。一方、分散型ならもっとうまくできる。つまり、必要なバージョンのクローンを手元につくればいい。

でも、クローンを作るってことは結局、作業ディレクトリとか、そのバージョン時点までのぜんぶの履歴をコピーすることになる。たしかにGitはファイルの共有とかハードリンクを使って無駄を省いてくれるけど、ファイルそのものは新しい作業ディレクトリに新しく再作成しなくちゃならない。

*解決*: Gitにはこういう状況に対するいい道具がある。そいつはクローンを作るよりも速いし、ディスクの無駄もない。*git branch* を使おう。

この呪文で、作業ディレクトリ内のファイルは突然別のバージョンに姿を変える。この変身は単に履歴の中を進んだり戻ったりできるってだけじゃない。最新のリリース用のバージョンから、実験用のバージョンにも移れるし、いま開発中のバージョンや友達のバージョンなんかにも移れる。

=== 「上司が来たぞ」キー ===

こんなゲームをやったことはないだろうか。特定のキー（上司キー）を押すと、突然画面がエクセルかなんかに切り替わる。なので、職場でゲームをやってるときに上司が来たら、そのキーを押して画面を隠せばいいみたいなやつだ。

好きなディレクトリでこうやってみよう。

 $ echo "ぼくは上司より利口だ" > myfile.txt
 $ git init
 $ git add .
 $ git commit -m "最初のコミット"

これでGitのレポジトリができた。その中には、あるメッセージの入った一つのファイルが管理されてる。じゃあ、次にこうしてみよう。

 $ git checkout -b boss  # こうやっても何も変わらないように見える
 $ echo "ぼくより上司のほうが賢い" > myfile.txt
 $ git commit -a -m "別のコミット"

こうすると、myfile.txtを上書きしてコミットしたように見える。でもそれは錯覚だ。こう打ってみよう。

 $ git checkout master  # 元のバージョンに切り替える

するとテキストファイルはなんと元通り！そしてもし上司がこのディレクトリを覗こうとしてるならこうすればいい。

 $ git checkout boss  # 上司に見られてもいいバージョンに切り替える

この二つのバージョンは好きなだけ切り替えられるし、コミットもそれぞれ互いに関係なくできる。

=== 汚れ仕事 ===

[[branch]]
ある部分を開発しているときに、何らかの理由で古いバージョンに戻る必要がでてきたとしよう。その中で、特定の箇所がどういうふうに動いてるかをみるために一時的にprint文を追加したい。そんな場合はこうしよう。

 $ git commit -a
 $ git checkout SHA1_HASH

これでもう、汚い一時的なコードをどこに足しても大丈夫だ。変更をコミットしてもいい。それが終わったら、

 $ git checkout master

とすれば元の作業に戻れる。古いバージョンに戻る時点でコミットされてなかった変更は引き継がれないことに注意しよう。

さっきの一時的な変更をやっぱり保存したかった場合も簡単で、

 $ git checkout -b dirty

としてから、マスターブランチに切り替える前にコミットすればいい。その後で一時的な汚いブランチの方に戻りたければ単にこう打つ。

 $ git checkout dirty

このコマンドについては、実は以前の章で触れている（古い状態に戻るっていう話題のときに）。さて、話をまとめるとこうだ。ファイルは指定した状態に変化する。でもそれにはマスターブランチを離れる必要がある。それ以降のコミットによって、ファイルはまた別の道を進むことになる。その道には後から名前をつけてもいい。

言いかえると、古い状態にチェックアウトした後は、自動的に名前のないブランチに切り替わる。それに名前をつけて保存するには *git checkout -b* とすればいい。

=== Quick Fixes ===

You're in the middle of something when you are told to drop everything and fix a newly discovered bug:

 $ git commit -a
 $ git checkout -b fixes SHA1_HASH

Then once you've fixed the bug:

 $ git commit -a -m "Bug fixed"
 $ git push  # to the central repository
 $ git checkout master

and resume work on your original task.

=== Uninterrupted Workflow ===

Some projects require your code to be reviewed before you may submit it. To make life easier for those reviewing your code, if you have a big change to make you might break it into two or more parts, and get each part separately reviewed.

What if the second part cannot be written until the first part is approved and checked in? In many version control systems, you'd have to send the first part to the reviewers, and then wait until it has been approved before starting on the second part.

Actually that's not quite true, but in these systems editing Part II before submitting Part I involves suffering and hardship. In Git, branching and merging are painless (a technical term for fast and local). So after you've committed the first part and sent it for review:

 $ git checkout -b part2

Next, code the second part of the big change without waiting for the first part to be accepted. When the first part is approved and submitted,

 $ git checkout master
 $ git merge part2
 $ git branch -d part2  # don't need this branch anymore

and the second part of the change is ready to review.

But wait! What if it wasn't that simple? Say you made a mistake in the first part, which you have to correct before submitting. No problem! First, switch back to the master branch with

 $ git checkout master

Fix the issue with the first part of the change and hope it gets approved. If not we simply repeat this step. You'll probably want to merge the fixed version of Part I into Part II as well:

 $ git checkout part2
 $ git merge master

Now it's the same as before. Once the first part has been approved and submitted:

 $ git checkout master
 $ git merge part2
 $ git branch -d part2

and again, the second part is ready to be reviewed.

It's easy to extend this trick for any number of parts.

=== Reorganizing a Medley ===

Perhaps you like to work on all aspects of a project in the same branch. You want to keep works-in-progress to yourself and want others to see your commits only when they have been neatly organized. Start a couple of branches:

  $ git checkout -b sanitized
  $ git checkout -b medley

Next, work on anything: fix bugs, add features, add temporary code, and so forth, committing often along the way. Then:

  $ git checkout sanitized
  $ git cherry-pick SHA1_HASH

applies a given commit to the "sanitized" branch. With appropriate cherry-picks you can construct a branch that contains only permanent code, and has related commits grouped together.

=== Managing Branches ===

List all branches by typing:

 $ git branch

There is always a branch named "master", and you start here by default. Some
advocate leaving the "master" branch untouched and creating new branches for
your own edits.

The *-d* and *-m* options allow you to delete and move (rename) branches.
See *git help branch*.

The "master" branch is a useful convention. Others may assume that your
repository has a branch with this name, and that it contains the official
version of your project. You can rename or obliterate the "master" branch, but
you might as well respect this custom.

=== Temporary Branches ===

After a while you may realize you are creating short-lived branches
frequently for similar reasons: every other branch merely serves to
save the current state so you can briefly hop back to an older state to
fix a high-priority bug or something.

It's analogous to changing the TV channel temporarily to see what else is on.
But instead of pushing a couple of buttons, you have to create, check out and
delete temporary branches and commits. Luckily, Git has a shorcut that
is as convenient as a TV remote control:

 $ git stash

This saves the current state in a temporary location (a 'stash') and
restores the previous state. Your working directory appears exactly as it was
before you started editing, and you can fix bugs, pull in upstream changes, and
so on. When you want to go back to the stashed state, type:

 $ git stash apply  # You may need to resolve some conflicts.

You can have multiple stashes, and manipulate them in various ways. See
*git help stash*. As you may have guessed, Git maintains branches behind the scenes to perform this magic trick.

=== Work How You Want ===

Applications such as http://www.mozilla.com/[Mozilla Firefox] allow you to open multiple tabs and multiple windows. Switching tabs gives you different content in the same window. Git branching is like tabs for your working directory. Continuing this analogy, Git cloning is like opening a new window. Being able to do both improves the user experience.

On a higher level, several Linux window managers support multiple desktops.
Branching in Git is similar to switching to a different desktop, while cloning
is similar to attaching another monitor to gain another desktop.

Yet another example is the http://www.gnu.org/software/screen/[*screen*] utility. This gem lets you create, destroy and switch between multiple terminal sessions in the same terminal. Instead of opening new terminals (clone), you can use the same one if you run *screen* (branch). In fact, you can do a lot more with *screen* but that's a topic for another text.

Cloning, branching, and merging are fast and local in Git, encouraging you to use the combination that best suits you. Git lets you work exactly how you want.
