== 基本的なしくみ ==

Gitコマンドの海にいきなり飛び込む前に、まずは基本的な例で足慣らしをしておこう。単純だけど、十分使えるものだ。じっさい、ぼくがGitを使い始めて最初の数ヶ月は、この章にあることは以外は使わなかったくらいだ。

=== 状態をセーブする ===

なにか思い切った変更をしようとしてるなら、その前に今のディレクトリの全ファイルのスナップショットをとっておこう。こんなふうに。

 $ git init
 $ git add .
 $ git commit -m "最初のバックアップ"

それで、新しい変更がうまくいかなかったらこうすればいい。

 $ git reset --hard

これで元通り。さらにこの状態をセーブしたければ、こうしよう。

 $ git commit -a -m "さらにバックアップ"

==== 追加、削除、名前変更 ====

上でやった作業では、最初に *git add* したときにあったファイルしか追跡してもらえない。もしも新しいファイルやディレクトリを追加した場合は、Gitにそれを教えてあげよう。

 $ git add NEWFILES...

同じように、たとえば削除したファイルについてGitに追跡をやめてもらいたいときは、こうすればいい。

 $ git rm OLDFILES...

ファイルの名前変更は、ファイルを削除して新しい名前のファイルを作るのと同じだ。ショートカットとして *git mv* というコマンドもある。使い方は普通のmvコマンドといっしょで、たとえばこうすればいい。

 $ git mv OLDFILE NEWFILE

=== より進んだアンドゥとリドゥ ===

ある時点に戻って、それ以降の変更をぜんぶなかったことにしたいことがある。ある時点での変更以降で内容が壊れてしまったときとかね。そういうときはこうしよう。

 $ git log

すると最近のコミットとそのSHA1ハッシュ値の一覧が表示されるので、次にこう打とう。

 $ git reset --hard SHA1_HASH

こうするとそのコミット時点の状態に戻り、それ以降のコミットの記録は完全に削除される。

そのほか、古い時点の状態をちょっとだけ見てみたいときもある。そういうときはこうすればいい。

 $ git checkout SHA1_HASH

これで、それ以降の新しいコミットの状態を保ったまま、古い時点に戻ることができる。ただし、SFの時間旅行と同じで、もしその状態から何か変更してコミットしたら、それはこれまでとは違うもう一つの現実になる。なぜなら、その変更は当初の時点で行われたものとは違うからだ。

このもう一つの現実はブランチと呼ばれる。そして <<branch,ブランチについては後でまた見ることになる>>。ひとまずは、現在に戻りたかったらこうすればいい。

 $ git checkout master

ただし、そうする前にそれまでの変更をコミットするかリセットするかしておこう。さもないGitに文句をいわれる。

ゲームのたとえ話に戻ると、こうなる。

- *`git reset --hard`*: 古いセーブデータを呼び出して、それより新しいすべてのデータを消すこと。

- *`git checkout`*: 古いセーブデータを呼び出すこと。ただし、そこからゲームを続けると、状態は当初の履歴とはだんだんずれていく。その状態でセーブすると、もう一つの現実に対応するようなブランチができる。 <<branch,ブランチについては後でまた扱う>>。

特定のファイルやディレクトリだけを選ぶこともできる。コマンドの後に指定してやればいい。

 $ git checkout SHA1_HASH some.file another.file

この形の *checkout* は、ひそかにファイルを上書きするので気をつけよう. 事故を防ぎたかったら、checkout する前に必ず commit したほうがいい。とくに、Gitに不慣れなうちはね。一般的に、何が起こるか自分でもよく分からない操作をする前は、それがGitコマンドかどうかにかかわらず、まず *git commit -a* するべきだ。

SHA1ハッシュ値をカット＆ペーストするのがいやなら、こういう手もある。

 $ git checkout :/"最初のバ"

こうすると、コミットメッセージがその文字列で始まるコミットに戻れる。最後から５番目にセーブした状態をとってくることもできる。こうすればいい。

 $ git checkout master~5

==== 元に戻す ====

たとえば裁判では、出来事が記録から削除されることがある。それと似たような感じで、特定のコミットだけを選んでアンドゥさせることができる。

 $ git commit -a
 $ git revert SHA1_HASH

こうすると、指定したハッシュ値のコミットだけがアンドゥされる。*git log* でログを見ると分かるけど、このrevertはそれ自身が新しいコミットとして記録される。

=== 変更履歴をつくる ===

プロジェクトによっては http://en.wikipedia.org/wiki/Changelog[変更履歴] が必要になるかもしれないね。変更履歴はこうすればかんたんに作れる。

 $ git log > ChangeLog

=== まとめてダウンロードする ===

Gitで管理されたプロジェクトのコピーは、こうやれば手に入る。

 $ git clone git://server/path/to/files

たとえばぼくがこのサイトを作るのにつかったすべてのファイルを持ってくるなら、こうだ。

 $ git clone git://git.or.cz/gitmagic.git

*clone* コマンドについてはまた後でくわしく見ていこう。

=== 最新の状態を手に入れる ===

*git clone* でプロジェクトのコピーを手に入れたら、次のコマンドでファイルを最新の状態に更新できる。

 $ git pull

=== 公開も簡単 ===

みんなに公開したいと思うようなスクリプトを書いたとしよう。その場合、単に自分のサーバからダウンロードしてもらってもいいけど、そうすると、スクリプトを直してたり、ちょっと実験するためにいじってる最中にだれかにダウンロードされると、問題が起きるはめになる。だからリリースのサイクルってやつを考えなくちゃいけない。開発者がプロジェクトをちょくちょく進めたとしても、それを公開するのはそうしてもいいと思うときだけだ。

これをGitでやるには、スクリプトのあるディレクトリでまずこうする。

 $ git init
 $ git add .
 $ git commit -m "最初のリリース"

それから、スクリプトをダウンロードするためには以下のコマンドを実行してねとみんなに伝えよう。

 $ git clone your.computer:/path/to/script

これは、みんながsshでアクセスできることを前提にしてる。そうじゃなければ、*git daemon* を実行してから、代わりに以下のコマンドを打ってもらうように頼もう。

 $ git clone git://your.computer/path/to/script

これ以降は、リリースの準備ができるたびに以下のコマンドを打てばいい。

 $ git commit -a -m "次のリリース"

そうしたら他のユーザは、スクリプトのあるディレクトリで以下を実行すればそれをバージョンアップできるんだ。

 $ git pull

これで、変更途中の見られたくないスクリプトがみんなに渡ることはなくなる。当たり前だけど、この方法はスクリプトだけじゃなくて他のどんなものについても使えるよ。

=== どんな変更をしたのか？ ===

最後のコミット以降にどんな変更があったかを知りたい場合はこうしよう。

 $ git diff

あるいは、昨日以降の変更が知りたければこう。

 $ git diff "@{yesterday}"

特定のバージョンと、最後から２世代前との間の比較ならこうだ。

 $ git diff SHA1_HASH "master~2"

どの場合も、出力結果はパッチの形式になっていて、 *git apply* でそれを適用することができる。次のコマンドも試してほしい。

 $ git whatchanged --since="2 weeks ago"

ぼくはよく http://sourceforge.net/projects/qgit[qgit] で履歴を見たりする。かっこよくて見た目がいいからね。それか、通信速度が遅い環境でも大丈夫なテキストベースの http://jonas.nitro.dk/tig/[tig] とか。さらには、ウェブサーバをインストールして *git instaweb* を実行すれば、ブラウザからでもアクセスすることもできるよ。

=== 練習問題 ===

A, B, C, D を連続した４つのコミットとしよう。BはAからファイルをいくつか消したものだ。いま、その消されたファイルをDに追加したい。どうすればいい？

やり方は少なくとも３つある。いま自分がDにいるとして、

  1. AとBの違いは消されたファイルだけだ。その差分をあらわすパッチをつくって適用してやればいい。

   $ git diff B A | git apply

  2. Aにはファイルが残っているので、必要なものだけとってきてやればいい。

   $ git checkout A FILES...

  3. AからBへの変化をアンドゥしてやればいい。

   $ git revert B

どれが一番いいだろう？どれでも好きなやつでいい。Gitで何かをするのは簡単だし、やり方はたいていいくつかあるんだ。
