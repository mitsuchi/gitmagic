== 基本的なしくみ ==

広大なGitコマンドの海にいきなり飛び込む前に、まずは簡単な例で慣れておこう。簡単だけど、十分実用的だ。じっさい、ぼくがGitを使い始めて最初の数ヶ月は、この章にあることは以外は使わなかった。

=== 状態をセーブする ===

なにか思い切った変更をしようとしてるなら、その前に次のコマンドで今のディレクトリの全ファイルのスナップショットをとっておこう。

 $ git init
 $ git add .
 $ git commit -m "最初のバックアップ"

それで、新しい変更がうまくいかなかったらこうすればいい。

 $ git reset --hard

これで元通り。さらにこの状態をセーブしたければ、こうすればいい。

 $ git commit -a -m "さらにバックアップ"

==== 追加、削除、名前変更 ====

上でやった作業では、最初に *git add* したときにあったファイルしか追跡してくれない。もしも新しいファイルやディレクトリを追加した場合は、次のコマンドでGitに教えてあげよう。

 $ git add NEWFILES...

同じように、たとえば削除したファイルとかについてGitに追跡をやめてもらいたいときは、こうすればい。

 $ git rm OLDFILES...

ファイルの名前変更は、ファイルを削除して新しい名前のファイルを作るのと同じだ。ショートカットとして *git mv* というコマンドもある。使い方は普通のmvコマンドといっしょで、たとえばこうすればいい。

 $ git mv OLDFILE NEWFILE

=== より進んだアンドゥとリドゥ ===

ある時点に戻って、それ以降の変更をぜんぶなかったことにしたいことがある。ある時点での変更以降で内容が壊れてしまったときとか。そういうときはまずこうする。

 $ git log

最近のコミットとそのSHA1ハッシュ値の一覧が表示されるので、次にこう打つ。

 $ git reset --hard SHA1_HASH

こうするとそのコミット時点の状態に戻り、それ以降のコミットの記録は完全に削除される。

そのほか、古い時点の状態をちょっとだけ見てみたいときもある。そういうときはこうすればいい。

 $ git checkout SHA1_HASH

これで、それ以降の新しいコミットの状態も保ったまま、古い時点に戻ることができる。ただし、SFの時間旅行と同じで、もしその状態から何か変更してコミットしたら、それはこれまでとは違うもう一つの現実になる。なぜなら、その変更は当初の時点で行われたものとは違うからだ。

このもう一つの現実はブランチと呼ばれる。そして <<ブランチについては後でまた見ることになる>>. ひとまずは、現在に戻りたかったらこうすればいい。

 $ git checkout master

ただし、そうする前にそれまでの変更をコミットするかリセットするかしておこう。さもないGitに文句をいわれる。

ゲームのたとえ話に戻ると、こうなる。

- *`git reset --hard`*: 古いセーブデータを呼び出して、それより新しいすべてのデータを消すこと。

- *`git checkout`*: 古いセーブデータを呼び出す。ただし、そこからゲームを続けると、状態は当初の履歴とはだんだんずれていく。その状態でセーブすると、もう一つの現実に対応するようなブランチができる。 <<ブランチについては後でまた扱う>>.

特定のファイルやディレクトリだけを選ぶこともできる。コマンドの後に指定してやればいい。

 $ git checkout SHA1_HASH some.file another.file

この形の *checkout* は、ひそかにファイルを上書きするので気をつけよう. 事故を防ぎたかったら、checkout する前に必ず commit したほうがいい。とくに、Gitに不慣れなうちは。一般には、何が起こるか確かでない操作をする前は、それがGitコマンドかどうかにかかわらず、まず *git commit -a* するべきだ。

SHA1ハッシュ値をカット＆ペーストするのがいやなら、こういう手もある。

 $ git checkout :/"最初のバ"

こうすると、コミットメッセージがその文字列で始まるコミットに戻れる。最後から５番目にセーブした状態をとってくることもできる。こうすればいい。

 $ git checkout master~5

==== 元に戻す ====

裁判所では、出来事が記録が削除されることがある。それと似たような感じで、特定のコミットだけを選んでアンドゥさせることができる。

 $ git commit -a
 $ git revert SHA1_HASH

こうすると、指定したハッシュ値のコミットだけがアンドゥされる。*git log* でログを見ると、このrevertが新しいコミットして記録されているのがわかる。

=== 変更履歴をつくる ===

プロジェクトによっては http://en.wikipedia.org/wiki/Changelog[変更履歴]が必要になるかもしれない。変更履歴はこうすればかんたんに作れる。

 $ git log > ChangeLog

=== まとめてダウンロードする ===

Gitで管理されたプロジェクトのコピーは、こうやれば手に入る。

 $ git clone git://server/path/to/files

たとえばぼくがこのサイトを作るのにつかったすべてのファイルを持ってくるなら、こう。

 $ git clone git://git.or.cz/gitmagic.git

*clone* コマンドについてはまた後でいっぱい扱う予定。

=== The Bleeding Edge ===

If you've already downloaded a copy of a project using *git clone*, you can upgrade to the latest version with:

 $ git pull

=== Instant Publishing ===

Suppose you've written a script you'd like to share with others. You could just tell them to download from your computer, but if they do so while you're improving the script or making experimental changes, they could wind up in trouble.  Of course, this is why release cycles exist. Developers may work on a project frequently, but they only make the code available when they feel it is presentable.

To do this with Git, in the directory where your script resides:

 $ git init
 $ git add .
 $ git commit -m "First release"

Then tell your users to run:

 $ git clone your.computer:/path/to/script

to download your script. This assumes they have ssh access. If not, run *git daemon* and tell your users to instead run:

 $ git clone git://your.computer/path/to/script

From now on, every time your script is ready for release, execute:

 $ git commit -a -m "Next release"

and your users can upgrade their version by changing to the directory containing your script and typing:

 $ git pull

Your users will never end up with a version of your script you don't want them to see. Obviously this trick works for anything, not just scripts.

=== What Have I Done? ===

Find out what changes you've made since the last commit with:

 $ git diff

Or since yesterday:

 $ git diff "@{yesterday}"

Or between a particular version and 2 versions ago:

 $ git diff SHA1_HASH "master~2"

In each case the output is a patch that can be applied with *git apply*.
Try also:

 $ git whatchanged --since="2 weeks ago"

Often I'll browse history with http://sourceforge.net/projects/qgit[qgit]
instead, due to its slick photogenic interface, or
http://jonas.nitro.dk/tig/[tig], a text-mode interface that works well over
slow connections. Alternatively, install a web server, run *git instaweb* and
fire up any web browser.

=== Exercise ===

Let A, B, C, D be four successive commits where B is the same as A except some files have been removed. We want to add the files back at D and not at B. How can we do this?

There are at least three solutions. Assuming we are at D:

  1. The difference between A and B are the removed files. We can create a patch representing this difference and apply it:

   $ git diff B A | git apply

  2. Since we saved the files back at A, we can retrieve them:

   $ git checkout A FILES...

  3. We can view going from A to B as a change we want to undo:

   $ git revert B

Which choice is best? Whichever you prefer most. It is easy to get what you want with Git, and often there are many ways to get it.
