== はじめに ==

最初に、バージョン管理っていうものを例え話で説明しようと思う。ちゃんとした説明が知りたかったら http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0[Wikipediaのバージョン管理システムの項目] を見てみてください。

=== 仕事も遊びだ ===

ぼくのゲーム歴は長い。だけどバージョン管理システムなんてものを使い始めたのはようやく大人になってからだ。そういう人はぼくだけじゃないと思う。だから、この二つを比べることで、説明も理解も簡単になるかもしれない。

ソースコードとか文書、なんでもいいんだけど、それらを編集することを、ゲームをすることに例えて考えてみよう。ゲームをたくさん進めたら、セーブしたくなる。そのためには、エディタの保存ボタンを押せばいい。

でもそうすると古いバージョンは上書きされちゃう。セーブできるスロットが一つしかない古いゲームみたいなもので、確かにセーブできるけど、それより前の状態には決して戻れない。それって困りものだ。もしかすると、前にセーブした時点はそのゲームの中でもとびきりに楽しい、もういっかいやりたいと思うくらいのところかもしれない。もっと悪い場合、いまのセーブ内容は実はハマリ状態になっていて、もういちど最初からやり直さないといけないかもしれない。

=== バージョン管理 ===

文書を編集するときは、「別名で保存」するか、最初にコピーをとっておくことで、古いバージョンのファイルをずっととっておくことができる。ディスクを節約したければ圧縮してもいい。これが原始的で労働集約型のバージョン管理だ。ゲームはこんな地点はとっくに通過してる。セーブスロットは複数あって、日時が自動的に記録されるのが普通だ。

状況をちょっとだけ難しくしてみよう。たとえば、互いに関連のあるファイル群があるとする。プロジェクトのソースコードとか、ウェブサイトのファイルとかだ。もしそれらの古いバージョンをとっておきたいとしたら、ディレクトリ全部を保存しておかないといけない。いくつものバージョンを手で管理するのは不便だし、すぐに大変になる。

いくつかのゲームでは、セーブデータは本当にディレクトリとファイルでできてる。だけど、そういう内部の詳細はプレイヤーからは隠されていて、用意された便利なインターフェースからいくつも異なるバージョンのディレクトリを管理できるようになっている。

バージョン管理システムはこれとまったく同じだ。ファイルやディレクトリを管理するための便利なインターフェースがあって、どんなに頻繁にセーブしたっていいし、そのセーブデータはどれでも後からロードできる。ゲームとは違って、ディスクをうまく節約するようにもできてる。ふつうは、バージョンごとに変わるのはいくつかのファイルだけなので、ファイル全体のコピーの代わりに、差分だけを保存することで空間が節約できる。

=== 分散管理 ===

すごく難しいゲームがあったとする。あまりにも難しすぎるので、手練のプレイヤーたちが世界中からあつまってチームをつくり、セーブデータを共有して立ち向かおうとするような場合を想像してほしい。ゲームの早解きなんかがその例だ。同じゲームのことなる部分の得意なプレイヤーたちが協力して、びっくりするような成果を上げる。

たがいのセーブデータを簡単にもらったりあげたりするようなシステムはどうやって作ったらいいんだろう？

昔は、どんなプロジェクトでも中央集権的なバージョン管理をしていた。どこかのサーバがすべてのセーブデータを抱えている。プレイヤーはせいぜいいくつかのセーブデータをそれぞれのマシンに持っているだけ。セーブデータを更新したいときは、まず中央のサーバから最新のデータをもってきて、何時間か遊んでセーブする。それを中央サーバにアップロードし直すことで、みんなが使えるようになる。

もし何かの理由で、古いセーブデータを使いたくなったらどうだろう？ もしかしたら、今のセーブデータは、誰かが３階にあるアイテムをゲットし忘れたせいですでにハマリ状態になっているかもしれない。だからゲームが続けられる最新の状態のセーブデータが欲しい。もしくは、ふたつのセーブデータを比べることで、あるプレイヤーがどれだけの仕事をしたのかを見たいかもしれない。

古いバージョンが欲しくなる理由はいくつもある。でも顛末はいつも同じだ。いつだって中央サーバに古いセーブデータをとりにいかなきゃいけない。セーブデータが増えれば、通信も増える。

新世代のバージョン管理システム（たとえばGit）は分散システムとして知られている。これは、中央集権型のシステムを一般化したものと考えることもできる。プレイヤーが中央サーバからダウンロードするデータには、すべてのセーブデータがはいっている。最新のだけじゃない。中央サーバをミラーリングしてるみたいなものだ。

最初にコピーしてくる操作は、とくに長い履歴があるような場合にはちょっと処理時間がかかるかもしれない。でも、そんなのはすぐ報われる。たとえば、古いセーブデータが欲しくなったら、中央サーバへの通信なしにいつでも手に入れることができる。それはすぐ得られる利点だ。

==== ばかげた迷信 ====

よくある誤解は、分散システムは公式の中央レポジトリを持つプロジェクトには向かないってものだ。これは真実からはほど遠い。写真をとっても魂が抜かれないのと一緒で、中央レポジトリーはコピーが作られてもその重要性はちっとも減らない。

おおまかにいえば、中央集権的なバージョン管理でできることは、よくできた分散システムならもっとよくできる。ネットワーク資源はローカルよりも単純に高くつく。後で見るように分散システムにも弱点はあるんだけど、でもどう大雑把にみてもその優位がくつがえることはない。

小さなプロジェクトなら、そういうシステムのごく一部だけが必要になるかもしれない。でも、小さなプロジェクトだからといってそれにしか向かないシステムを使うのは、小さな数の計算だからといってローマ数字を使うようなものだ。

それに、プロジェクトが当初の想像を超えて大きくなるかもしれない。最初からGitを使った方がいい。それは、たとえふだんは缶のふたを開けるぐらいしか用がなくても、スイス製の万能ナイフを携帯しておくのに似ている。いつかねじ回しが必要になったときに、自分の道具がただの缶切りでなくてよかったと思うだろう。

=== マージの衝突 ===

この話題のためには、いままでのゲームのたとえはちょっと無理がある。かわりに、文書を編集することをもう一度考えてみよう。

Aさんが文書の先頭に行を追加するとする。そしてBさんが自分の手元の同じ文書の最後に行を追加する。そして二人ともその変更をアップロードする。たいていのバージョン管理システムはこの状況を自動的にうまく扱う。両方を受け取って、マージする。そしてAさんとBさんの変更は両方とも適用される。

こんどは、AとBの両方が同じ行に違う変更を加えるとしよう。この場合は、さすがに人間が解決する必要がある。二番目にアップロードした人は、マージの衝突があったことを知らされるので、AとBのどちらかを選ぶか、あるいはその行をまったく違うように差しかえるかを選ばなきゃいけない。

もっと複雑な状況もありえる。バージョン管理システムは簡単な場合を扱い、難しい場合は人間に任せる。たいていそのふるまいは設定で変えられるようになっている。
