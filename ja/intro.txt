== はじめに ==

最初に、バージョン管理っていうものを例え話で説明しようと思う。ちゃんとした説明が知りたかったら http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0[Wikipediaのバージョン管理システムの項目] を見てみてください。

=== 仕事も遊びだ ===

ぼくのゲーム歴は長い。だけどバージョン管理システムなんてものを使い始めたのはようやく大人になってからだ。そういう人はぼくだけじゃないと思う。だから、この二つを比べることで、説明も理解も簡単になるかもしれない。

ソースコードとか文書、なんでもいいんだけど、それらを編集することを、ゲームをすることに例えて考えてみよう。ゲームをたくさん進めたら、セーブしたくなる。そのためには、エディタの保存ボタンを押せばいい。

でもそうすると古いバージョンは上書きされちゃう。セーブできるスロットが一つしかない古いゲームみたいなもので、確かにセーブできるけど、それより前の状態には決して戻れない。それって困りものだ。もしかすると、前にセーブした時点はそのゲームの中でもとびきりに楽しい、もういっかいやりたいと思うくらいのところかもしれない。もっと悪い場合、いまのセーブ内容は実はハマリ状態になっていて、もういちど最初からやり直さないといけないかもしれない。

=== バージョン管理 ===

文書を編集するときは、「別名で保存」するか、最初にコピーをとっておくことで、古いバージョンのファイルをずっととっておくことができる。ディスクを節約したければ圧縮してもいい。これが原始的で労働集約型のバージョン管理だ。ゲームはこんな地点はとっくに通過してる。セーブスロットは複数あって、日時が自動的に記録されるのが普通だ。

状況をちょっとだけ難しくしてみよう。たとえば、互いに関連のあるファイル群があるとする。プロジェクトのソースコードとか、ウェブサイトのファイルとかだ。もしそれらの古いバージョンをとっておきたいとしたら、ディレクトリ全部を保存しておかないといけない。いくつものバージョンを手で管理するのは不便だし、すぐに大変になる。

いくつかのゲームでは、セーブデータは本当にディレクトリとファイルでできてる。だけど、そういう内部の詳細はプレイヤーからは隠されていて、用意された便利なインターフェースからいくつも異なるバージョンのディレクトリを管理できるようになっている。

バージョン管理システムはこれとまったく同じだ。ファイルやディレクトリを管理するための便利なインターフェースがあって、どんなに頻繁にセーブしたっていいし、そのセーブデータはどれでも後からロードできる。ゲームとは違って、ディスクをうまく節約するようにもできてる。ふつうは、バージョンごとに変わるのはいくつかのファイルだけなので、ファイル全体のコピーの代わりに、差分だけを保存することで空間が節約できる。

=== 分散管理 ===

すごく難しいゲームがあったとする。あまりにも難しすぎるので、手練のプレイヤーたちが世界中からあつまってチームをつくり、セーブデータを共有して立ち向かおうとするような場合を想像してほしい。ゲームの早解きなんかがその例だ。同じゲームのことなる部分の得意なプレイヤーたちが協力して、びっくりするような成果を上げる。

たがいのセーブデータを簡単にもらったりあげたりするようなシステムはどうやって作ったらいいんだろう？

昔は、どんなプロジェクトでも中央集権的なバージョン管理をしていた。どこかのサーバがすべてのセーブデータを抱えている。プレイヤーはせいぜいいくつかのセーブデータをそれぞれのマシンに持っているだけ。セーブデータを更新したいときは、まず中央のサーバから最新のデータをもってきて、何時間か遊んでセーブする。それを中央サーバにアップロードし直すことで、みんなが使えるようになる。

もし何かの理由で、古いセーブデータを使いたくなったらどうだろう？ もしかしたら、今のセーブデータは、誰かが３階にあるアイテムをゲットし忘れたせいですでにハマリ状態になっているかもしれない。だからゲームが続けられる最新の状態のセーブデータが欲しい。もしくは、ふたつのセーブデータを比べることで、あるプレイヤーがどれだけの仕事をしたのかを見たいかもしれない。

古いバージョンが欲しくなる理由はいくつもある。でも顛末はいつも同じだ。いつだって中央サーバに古いセーブデータをとりにいかなきゃいけない。セーブデータが増えれば、通信も増える。

新世代のバージョン管理システム（たとえばGit）は分散システムとして知られている。これは、中央集権型のシステムを一般化したものと考えることもできる。プレイヤーが中央サーバからダウンロードするデータには、すべてのセーブデータがはいっている。最新のだけじゃない。中央サーバをミラーリングしてるみたいなものだ。

最初にコピーしてくる操作は、とくに長い履歴があるような場合にはちょっと処理時間がかかるかもしれない。でも、そんなのはすぐ報われる。たとえば、古いセーブデータが欲しくなったら、中央サーバへの通信なしにいつでも手に入れることができる。それはすぐ得られる利点だ。

==== A Silly Superstition ====

A popular misconception is that distributed systems are ill-suited for projects requiring an official central repository. Nothing could be further from the truth. Photographing someone does not cause their soul to be stolen. Similarly, cloning the master repository does not diminish its importance.

A good first approximation is that anything a centralized version control system can do, a well-designed distributed system can do better. Network resources are simply costlier than local resources. While we shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous comparisons with this rule of thumb.

A small project may only need a fraction of the features offered by such a
system, but saying you should use systems that don't scale well when your
project is tiny is like saying you should use Roman numerals for calculations
involving small numbers.

Moreover, your project may grow beyond your original expectations. Using Git from the outset is like carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately need a screwdriver you'll be glad you have more than a plain bottle-opener.

=== Merge Conflicts ===

For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider editing a document.

Suppose Alice inserts a line at the beginning of a file, and Bob appends one at the end of his copy. They both upload their changes. Most systems will automatically deduce a reasonable course of action: accept and merge their changes, so both Alice's and Bob's edits are applied.

Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to proceed without human intervention. The second person to upload is informed of a _merge conflict_, and must choose one edit over another, or revise the line entirely.

More complex situations can arise. Version control systems handle the simpler cases themselves, and leave the difficult cases for humans. Usually their behaviour is configurable.
