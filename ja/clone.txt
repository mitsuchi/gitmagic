== クローンを作る ==

古いバージョン管理システムでは、ファイルを手に入れるためのふつうの方法はチェックアウトだった。指定した保存状態のファイル群をそれで入手することができる。

Gitや他の分散バージョン管理システムでは、かわりにクローンを作るのがふつうだ。ファイルを入手するのに、レポジトリ全体のクローンを作る。言い換えると、実質的に中央サーバをミラーリングするってことだ。中央レポジトリでできることならなんでも、そこでもできる。

=== コンピュータどうしを同期する ===

ぼくが最初にGitを使った理由はこれだった。tarballを作ったり *rsync* でバックアップや簡単な同期をするのも確かにできる。でも、ときにはノートパソコンで、また別のときにはデスクトップでというふうに編集していると、両者が食い違っていってしまう。

そんなときは、Gitレポジトリを初期化してファイル群をコミットしよう。それから別のコンピュータ上で以下を実行する。

 $ git clone other.computer:/path/to/files

これで、ファイル群とGitレポジトリの二つ目のコピーができる。これ以降は、

 $ git commit -a
 $ git pull other.computer:/path/to/files HEAD

とすれば、他方のコンピュータの状態を手元に引っぱってくることができる。もしも同じファイルで変更がぶつかっていたらGitはそれを教えてくれるので、衝突を解決した後でコミットし直す必要がある。

=== 古典的なソース管理 ===

Gitを初期化して、レポジトリにファイル群を追加しよう。

 $ git init
 $ git add .
 $ git commit -m "最初のコミット"

それから中央サーバで、好きな名前の空のGitレポジトリを作る。必要ならGitデーモンを走らせておこう。

 $ GIT_DIR=proj.git git init
 $ git daemon --detach  # すでに別のが動いてることもある

Gitのホスティングサービスを使ってる場合は、サイトの指示にしたがって空のレポジトリを作ってほしい（たいていはそれ用のフォームに入力して作る）。

次のコマンドでプロジェクトを中央サーバにプッシュしよう。

 $ git push git://central.server/path/to/proj.git HEAD

これで準備完了。ソースを持ってくるには、開発者はこう打てばいい。

 $ git clone git://central.server/path/to/proj.git

いろいろ変更してから、ソースコードを次のようにして中央サーバに上げ直す。

 $ git commit -a
 $ git push

もしも中央サーバの方が更新されてたら、手元のをプッシュする前に最新版に上げる必要がある。最新版に同期するためにはこうしよう。

 $ git commit -a
 $ git pull

==== プッシュ vs プル ====

レポジトリにプッシュするってことはあまり行われない。なんでかっていうと、プッシュされる側に作業ディレクトリがあって、しかも最後のコミットから変更があったりする場合に混乱が起きるからだ。でも、裸のレポジトリにプッシュするのは簡単で、プルするよりもこの場合は目的にかなう。

サーバからプルしてくるためには、そのサーバでシェルを利用できる必要がある。それと、作業用のコンピュータのIPアドレスも知ってなきゃいけない。それに、ファイアーウォールがじゃまをするかもしれない。

=== プロジェクトを枝分かれさせる ===

何かのプロジェクトの進み方にうんざりして、自分ならもっとうまくできるのにって思ったりするかもしれない。そういうときはまずプロジェクトのクローンを作ろう。

 $ git clone git://main.server/path/to/files

それからみんなに、自分のサーバでプロジェクトを枝分かれさせたことを伝えよう。

もともとのプロジェクトで変更があった場合でも、次のようにすればいつでもその変更を取りこめる。

 $ git pull

=== 究極のバックアップ ===

ファイル群のバックアップが欲しいとしよう。それも、複数あって勝手に中身が変わることがなく、地理的にも離れた場所にあるようなのが欲しいとする。もしプロジェクトに開発者がたくさん参加してるなら、実はもうそれだけでいい。コードのそれぞれのクローンが、実用的なバックアップになっている。しかも単に現在の状態だけじゃなく、プロジェクトの全履歴がバックアップされてるのだ。暗号学的なハッシュのおかげで、だれかのクローンが壊れてしまったとしても、他と通信があった時点ですぐに発見される。
もしプロジェクトがそれほど有名じゃなければ、できるだけ多くのサーバを見つけてクローンをつくっておこう。

もし本当に気になるなら、HEADの最新の20バイトのSHA1ハッシュ値をどこか安全な場所に書いておくといい。秘密にするんじゃなくて、安全にしよう。たとえば新聞に載せちゃってもいい。もし悪さをしようとする人がいても、新聞ぜんぶの紙面を後から変えるのはさすがに難しいだろうから。

=== 光速で同時に ===

いくつかの主要な機能を並行して開発したいとしよう。そのためには、現在のプロジェクトをまずコミットしてからこう打つ。

 $ git clone . /some/new/directory

Gitはハードリンクやファイルの共有をできる限りうまく利用しようとする。なのでクローンは一瞬でできる。そしたら、あとは独立した二つの機能を同時に開発していくことができる。たとえば、片方をコンパイルしてる間に、もう片方をいじることもできる。

いつでもコミットして、他のクローンでの変更を取り込むことができる。こうすればいい。

 $ git pull /the/other/clone HEAD

=== ゲリラ的なバージョン管理 ===

参加してるプロジェクトで使ってるバージョン管理システムがGitじゃなくてとても残念に思うことがあったりしないだろうか。そんなときは自分の作業ディレクトリでGitレポジトリを初期化しよう。

 $ git init
 $ git add .
 $ git commit -m "最初のコミット"

そしたらそれをクローンする:

 $ git clone . /some/new/directory

クローンした先の新しいディレクトリに移って、そこでGitを使って開発を進めよう。ときどき他の開発者との間で同期をとりたくなったら、もとのディレクトリに戻って、別のバージョン管理システムで同期をとった上で、こうする。

 $ git add .
 $ git commit -m "みんなと同期をとった"

それから新しいディレクトリに移って、以下を実行しよう。

 $ git commit -a -m "自分の変更に関する記述"
 $ git pull

自分の変更をみんなのものに反映させる手順は、その別のバージョン管理システムによって変わってくる。新しいディレクトリには自分の変更したファイルがある。別のバージョン管理システムでの適切なコマンドを使って、それらを中央サーバのレポジトリにアップロードしよう。

*git svn* コマンドは上の手順をSubversionoのレポジトリについて自動化してくれる。そして、 http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html[GitプロジェクトをSubversionレポジトリに変換する] ためにも使うことができる。
